diff --git a/src/lib/node-modules-utils.js b/src/lib/node-modules-utils.js
index 05226f66bf42fc0a07588d373b14932cbeb9ff7f..a86924565e964815769e1fc788bf5c6cb6454083 100644
--- a/src/lib/node-modules-utils.js
+++ b/src/lib/node-modules-utils.js
@@ -29,6 +29,28 @@ async function getNodeModulesLocationForPackage(packageName) {
   return nodeModulesUrl;
 }
 
+function resolveBareSpecifier(specifier) {
+  let resolvedPath;
+
+  // sometimes a package.json has no main field :/
+  // https://unpkg.com/browse/@types/trusted-types@2.0.7/package.json
+  try {
+    resolvedPath = import.meta.resolve(specifier);
+  } catch (e) {
+    // TODO console.log(`WARNING: unable to resolve specifier \`${specifier}\``);
+  }
+
+  return resolvedPath;
+}
+
+function resolveRootForSpecifier(specifier) {
+  const resolved = resolveBareSpecifier(specifier);
+
+  if (resolved) {
+    return `${resolved.split(specifier)[0]}${specifier}/`;
+  }
+}
+
 // extract the package name from a URL like /node_modules/<some>/<package>/index.js
 function getPackageNameFromUrl(url) {
   const packagePathPieces = url.split('node_modules/')[1].split('/'); // double split to handle node_modules within nested paths
@@ -58,5 +80,7 @@ async function getPackageJson({ userWorkspace, projectDirectory }) {
 export {
   getNodeModulesLocationForPackage,
   getPackageJson,
-  getPackageNameFromUrl
+  getPackageNameFromUrl,
+  resolveBareSpecifier,
+  resolveRootForSpecifier
 };
\ No newline at end of file
diff --git a/src/lib/walker-package-ranger.js b/src/lib/walker-package-ranger.js
index a92bb3d29496a453f1714e5cd32d1800c94844be..68fd30e718f5493b426b88bc8e6aa13753c2c2c0 100644
--- a/src/lib/walker-package-ranger.js
+++ b/src/lib/walker-package-ranger.js
@@ -1,217 +1,120 @@
-/* eslint-disable max-depth,complexity */
-import * as acorn from 'acorn';
-import fs from 'fs';
-import { getNodeModulesLocationForPackage } from './node-modules-utils.js';
-import path from 'path';
-import * as walk from 'acorn-walk';
+import fs from 'fs/promises';
+import { resolveBareSpecifier } from './node-modules-utils.js';
 
+/* eslint-disable max-depth,complexity */
 const importMap = {};
+const extensionFilters = ['map', 'd.ts'];
 
-const updateImportMap = (entry, entryPath) => {
+function updateImportMap(key, value) {
+  importMap[key.replace('./', '')] = value.replace('./', '');
+}
 
-  if (path.extname(entryPath) === '') {
-    entryPath = `${entryPath}.js`;
-  }
+// https://nodejs.org/api/packages.html#subpath-patterns
+async function walkExportPatterns(dependency, exp, resolvedRoot) {
+  if (exp.endsWith('*')) {
+    const dir = new URL(exp.replace('*', ''), resolvedRoot);
+    const files = await fs.readdir(dir);
+    // console.log({ dependency, exp, dir });
 
-  // handle WIn v Unix-style path separators and force to /
-  importMap[entry.replace(/\\/g, '/')] = entryPath.replace(/\\/g, '/');
-};
+    files
+      .filter((file) => {
+        let shouldNotFilter = true;
 
-// handle ESM paths that have varying levels of nesting, e.g. export * from '../../something.js'
-// https://github.com/ProjectEvergreen/greenwood/issues/820
-async function resolveRelativeSpecifier(specifier, modulePath, dependency) {
-  const absoluteNodeModulesLocation = await getNodeModulesLocationForPackage(dependency);
-
-  // handle WIn v Unix-style path separators and force to /
-  return `${dependency}${path.join(path.dirname(modulePath), specifier).replace(/\\/g, '/').replace(absoluteNodeModulesLocation.replace(/\\/g, '/', ''), '')}`;
-}
+        extensionFilters.forEach((extFilter) => {
+          if (file.endsWith(extFilter)) {
+            shouldNotFilter = false;
+          }
+        });
 
-async function getPackageEntryPath(packageJson) {
-  let entry = packageJson.exports
-    ? Object.keys(packageJson.exports) // first favor export maps first
-    : packageJson.module // next favor ESM entry points
-      ? packageJson.module
-      : packageJson.main && packageJson.main !== '' // then favor main
-        ? packageJson.main
-        : 'index.js'; // lastly, fallback to index.js
-
-  // use .mjs version if it exists, for packages like redux
-  if (!Array.isArray(entry) && fs.existsSync(`${await getNodeModulesLocationForPackage(packageJson.name)}/${entry.replace('.js', '.mjs')}`)) {
-    entry = entry.replace('.js', '.mjs');
+        return shouldNotFilter;
+      })
+      .forEach((file) => {
+        updateImportMap(`${dependency}/${exp.replace('/*', '')}/${file}`, `/node_modules/${dependency}/${exp.replace('/*', '')}/${file}`);
+      });
+  } else {
+    // TODO
+    // "./feature/*": "./feature/*.js",
   }
-
-  return entry;
 }
 
-async function walkModule(modulePath, dependency) {
-  const moduleContents = fs.readFileSync(modulePath, 'utf-8');
-
-  walk.simple(acorn.parse(moduleContents, {
-    ecmaVersion: '2020',
-    sourceType: 'module'
-  }), {
-    async ImportDeclaration(node) {
-      let { value: sourceValue } = node.source;
-      const absoluteNodeModulesLocation = await getNodeModulesLocationForPackage(dependency);
-      const isBarePath = sourceValue.indexOf('http') !== 0 && sourceValue.charAt(0) !== '.' && sourceValue.charAt(0) !== path.sep;
-      const hasExtension = path.extname(sourceValue) !== '';
-
-      if (isBarePath && !hasExtension) {
-        if (!importMap[sourceValue]) {
-          updateImportMap(sourceValue, `/node_modules/${sourceValue}`);
-        }
+async function walkPackageForExports(dependency, packageJson, resolvedRoot) {
+  const { exports, module, main } = packageJson;
 
-        await walkPackageJson(path.join(absoluteNodeModulesLocation, 'package.json'));
-      } else if (isBarePath) {
-        updateImportMap(sourceValue, `/node_modules/${sourceValue}`);
-      } else {
-        // walk this module for all its dependencies
-        sourceValue = !hasExtension
-          ? `${sourceValue}.js`
-          : sourceValue;
+  console.log('walkPackageForExports', { dependency, exports, module, main });
 
-        if (fs.existsSync(path.join(absoluteNodeModulesLocation, sourceValue))) {
-          const entry = `/node_modules/${await resolveRelativeSpecifier(sourceValue, modulePath, dependency)}`;
-          await walkModule(path.join(absoluteNodeModulesLocation, sourceValue), dependency);
-
-          updateImportMap(path.join(dependency, sourceValue), entry);
-        }
-      }
-    },
-    async ExportNamedDeclaration(node) {
-      const sourceValue = node && node.source ? node.source.value : '';
-
-      if (sourceValue !== '' && sourceValue.indexOf('http') !== 0) {
-        // handle relative specifier
-        if (sourceValue.indexOf('.') === 0) {
-          const entry = `/node_modules/${await resolveRelativeSpecifier(sourceValue, modulePath, dependency)}`;
-
-          updateImportMap(path.join(dependency, sourceValue), entry);
+  if (exports) {
+    for (const exp in exports) {
+      if (typeof exports[exp] === 'object') {
+        if (exports[exp].import) {
+          if (typeof exports[exp].import === 'object') {
+            if (exp === '.') {
+              updateImportMap(dependency, `/node_modules/${dependency}/${exports[exp].import.default ?? exports[exp].import }`);
+            } else {
+              updateImportMap(`${dependency}/${exp}`, `/node_modules/${dependency}/${exports[exp].import.default ?? exports[exp].import}`);
+            }
+          }
+        } else if (exports[exp].default) {
+          if (exp === '.') {
+            updateImportMap(dependency, `/node_modules/${dependency}/${exports[exp].default}`);
+          } else {
+            updateImportMap(`${dependency}/${exp}`, `/node_modules/${dependency}/${exports[exp].default}`);
+          }
         } else {
-          // handle bare specifier
-          updateImportMap(sourceValue, `/node_modules/${sourceValue}`);
+          // TODO what to do here?  what else is there besides default?
         }
-      }
-    },
-    async ExportAllDeclaration(node) {
-      const sourceValue = node && node.source ? node.source.value : '';
-
-      if (sourceValue !== '' && sourceValue.indexOf('http') !== 0) {
-        if (sourceValue.indexOf('.') === 0) {
-          const entry = `/node_modules/${await resolveRelativeSpecifier(sourceValue, modulePath, dependency)}`;
-
-          updateImportMap(path.join(dependency, sourceValue), entry);
+      } else {
+        if (exp === '.') {
+          updateImportMap(dependency, `/node_modules/${dependency}/${exports[exp]}`);
+        } else if (exp.indexOf('*') >= 0) {
+          await walkExportPatterns(dependency, exp, resolvedRoot);
         } else {
-          updateImportMap(sourceValue, `/node_modules/${sourceValue}`);
+          updateImportMap(`${dependency}/${exp}`, `/node_modules/${dependency}/${exp}`);
         }
       }
     }
-  });
+  } else if (module || main) {
+    updateImportMap(dependency, `/node_modules/${dependency}/${module ?? main}`);
+  }
 }
 
+// https://nodejs.org/api/packages.html#package-entry-points
 async function walkPackageJson(packageJson = {}) {
-  // while walking a package.json we need to find its entry point, e.g. index.js
-  // and then walk that for import / export statements
-  // and walk its package.json for its dependencies
-
-  for (const dependency of Object.keys(packageJson.dependencies || {})) {
-    const dependencyPackageRootPath = path.join(process.cwd(), 'node_modules', dependency);
-    const dependencyPackageJsonPath = path.join(dependencyPackageRootPath, 'package.json');
-    const dependencyPackageJson = JSON.parse(fs.readFileSync(dependencyPackageJsonPath, 'utf-8'));
-    const entry = await getPackageEntryPath(dependencyPackageJson);
-    const isJavascriptPackage = Array.isArray(entry) || typeof entry === 'string' && entry.endsWith('.js') || entry.endsWith('.mjs');
-
-    if (isJavascriptPackage) {
-      const absoluteNodeModulesLocation = await getNodeModulesLocationForPackage(dependency);
-
-      // https://nodejs.org/api/packages.html#packages_determining_module_system
-      if (Array.isArray(entry)) {
-        // we have an exportMap
-        const exportMap = entry;
-
-        for (const entry of exportMap) {
-          const exportMapEntry = dependencyPackageJson.exports[entry];
-          let packageExport;
-
-          if (Array.isArray(exportMapEntry)) {
-            let fallbackPath;
-            let esmPath;
-
-            exportMapEntry.forEach((mapItem) => {
-              switch (typeof mapItem) {
-
-                case 'string':
-                  fallbackPath = mapItem;
-                  break;
-                case 'object':
-                  const entryTypes = Object.keys(mapItem);
-
-                  if (entryTypes.import) {
-                    esmPath = entryTypes.import;
-                  } else if (entryTypes.require) {
-                    console.error('The package you are importing needs commonjs support.  Please use our commonjs plugin to fix this error.');
-                    fallbackPath = entryTypes.require;
-                  } else if (entryTypes.default) {
-                    console.warn('The package you are requiring may need commonjs support.  If this module is not working for you, consider adding our commonjs plugin.');
-                    fallbackPath = entryTypes.default;
-                  }
-                  break;
-                default:
-                  console.warn(`Sorry, we were unable to detect the module type for ${mapItem} :(.  please consider opening an issue to let us know about your use case.`);
-                  break;
-
-              }
-            });
-
-            packageExport = esmPath
-              ? esmPath
-              : fallbackPath;
-          } else if (exportMapEntry.import || exportMapEntry.default) {
-            packageExport = exportMapEntry.import
-              ? exportMapEntry.import
-              : exportMapEntry.default;
-
-            // use the dependency itself as an entry in the importMap
-            if (entry === '.') {
-              updateImportMap(dependency, `/node_modules/${path.join(dependency, packageExport)}`);
+  console.log({ packageJson });
+  try {
+    for (const dependency of Object.keys(packageJson.dependencies || {})) {
+      const resolved = resolveBareSpecifier(dependency);
+      
+      console.log({ dependency, resolved });
+      if (resolved) {
+        console.log(resolved.split(`/node_modules/${dependency}/`)[0]);
+        const resolvedRoot = new URL(`./node_modules/${dependency}/`, `${resolved.split(`/node_modules/${dependency}/`)[0]}/`);
+        console.log({ resolvedRoot })
+        const resolvedPackageJson = (await import(new URL('./package.json', resolvedRoot), { with: { type: 'json' } })).default;
+
+        console.log({ resolvedPackageJson });
+        walkPackageForExports(dependency, resolvedPackageJson, resolvedRoot);
+
+        if (resolvedPackageJson.dependencies) {
+          for (const dependency in resolvedPackageJson.dependencies) {
+            const resolved = resolveBareSpecifier(dependency);
+
+            if (resolved) {
+              const resolvedRoot = new URL(`./node_modules/${dependency}/`, `${resolved.split(`/node_modules/${dependency}/`)[0]}/`);
+              const resolvedPackageJson = (await import(new URL('./package.json', resolvedRoot), { with: { type: 'json' } })).default;
+
+              walkPackageForExports(dependency, resolvedPackageJson, resolvedRoot);
+
+              await walkPackageJson(resolvedPackageJson);
             }
-          } else if (exportMapEntry.endsWith && (exportMapEntry.endsWith('.js') || exportMapEntry.endsWith('.mjs')) && exportMapEntry.indexOf('*') < 0) {
-            // is probably a file, so _not_ an export array, package.json, or wildcard export
-            packageExport = exportMapEntry;
           }
-
-          if (packageExport) {
-            const packageExportLocation = path.resolve(absoluteNodeModulesLocation, packageExport);
-
-            if (packageExport.endsWith('js')) {
-              updateImportMap(path.join(dependency, entry), `/node_modules/${path.join(dependency, packageExport)}`);
-            } else if (fs.lstatSync(packageExportLocation).isDirectory()) {
-              fs.readdirSync(packageExportLocation)
-                .filter(file => file.endsWith('.js') || file.endsWith('.mjs'))
-                .forEach((file) => {
-                  updateImportMap(path.join(dependency, packageExport, file), `/node_modules/${path.join(dependency, packageExport, file)}`);
-                });
-            } else {
-              console.warn('Warning, not able to handle export', path.join(dependency, packageExport));
-            }
-          }
-        }
-
-        await walkPackageJson(dependencyPackageJson);
-      } else {
-        const packageEntryPointPath = path.join(absoluteNodeModulesLocation, entry);
-
-        // sometimes a main file is actually just an empty string... :/
-        if (fs.existsSync(packageEntryPointPath)) {
-          updateImportMap(dependency, `/node_modules/${path.join(dependency, entry)}`);
-
-          await walkModule(packageEntryPointPath, dependency);
-          await walkPackageJson(dependencyPackageJson);
         }
       }
     }
+  } catch (e) {
+    console.error('Error building up import map', e);
   }
 
+  console.log({ importMap });
   return importMap;
 }
 
@@ -245,7 +148,6 @@ function mergeImportMap(html = '', map = {}, shouldShim = false) {
 }
 
 export {
-  mergeImportMap,
   walkPackageJson,
-  walkModule
+  mergeImportMap
 };
